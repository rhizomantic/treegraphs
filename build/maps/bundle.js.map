{"version":3,"sources":["main.js","spread.js","render.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../bundle.js","sourcesContent":["var tickers = new Set();\r\nvar t = 0;\r\nvar seed;\r\nvar density;\r\nvar go = true;\r\nvar render;\r\nvar canvas, editor;\r\n\r\n// pi/2 = 1.5707\r\n// pi/3 = 1.047\r\n// pi/4 = 0.7853\r\nvar graphs = [];\r\n\r\nvar def = {\r\n    \"props\": {\r\n        \"render\": \"curves\",\r\n        \"renderConfig\": { \"type\": \"petals\", \"levels\": [['#FFCC0088', 8], ['rgba(255, 0, 0, 0.1)', 4]] }\r\n    },\r\n    \"net\": {\r\n        \"type\": \"fan\", \"num\": 35, \"pos\": [ 500, 400 ], \"ang\": 0, \"step\": {\"ease\":\"sine\", \"pow\": -3, \"terms\": \"noise*0.8+t*0.2\", \"min\": 30, \"max\": 480, \"dur\": 200}, \"turn\": 6.28/35, \"children\": [\r\n            //{ \"type\": \"chain\", \"num\": 3,  \"step\": 40, \"turn\": 0.5 }\r\n        ]\r\n    }\r\n};\r\n\r\n\r\n\r\nfunction setup() {\r\n    canvas = createCanvas(windowWidth, windowHeight);\r\n    canvas.parent('container');\r\n    background(\"#FFFFFF\");\r\n    //frameRate(30);\r\n    stroke(0, 128);\r\n    strokeWeight(3);\r\n    //fill(0, 32);\r\n    noFill();\r\n    smooth();\r\n\r\n    reset();\r\n\r\n    console.log(\"setup\");\r\n}\r\n\r\nfunction reset() {\r\n  //tickers.clear();\r\n  background(\"#FFFFFF\");\r\n  t = 0;\r\n  seed = int(random(999999));\r\n  randomSeed(seed);\r\n  noiseSeed(seed);\r\n\r\n  graphs = [];\r\n  let _def = generate();\r\n  var k = new Graph( _def );\r\n  graphs.push(k);\r\n\r\n  render = new RenderCurves(_def);\r\n\r\n  editor = select(\"#editor\");\r\n  let area = select(\"#editor-area\");\r\n  area.value( JSON.stringify(_def, replacer, 2) );\r\n\r\n  //text(defString, 20, 20);\r\n}\r\n\r\nfunction replacer(key, val) {\r\n    if(typeof(val) == \"number\") return Math.floor(val*100)/100;\r\n    return val;\r\n}\r\n\r\nfunction generate() {\r\n    let budget = 120;\r\n    let total = 0;\r\n    let def = {\r\n        props:{\r\n            \"render\": \"curves\",\r\n            \"renderConfig\": { \"type\": \"tree\", \"levels\": [[0, 8], ['#FFFFFF', 4]] }\r\n        },\r\n        net:[]\r\n    };\r\n    let dad = def.net;\r\n    let dn = 1;\r\n\r\n    while(total < budget*0.8) {\r\n        let num = Math.floor( Math.pow(Math.random(), 2) * 10 ) + 2;\r\n        while(total + dn*num > budget && num > 1) {\r\n            num --;\r\n            console.log(num, dn, total);\r\n        }\r\n        let neo = {\r\n            num: num,\r\n            type: Math.random() < 0.6 ? \"fan\" : \"chain\",\r\n            step: { min:Math.random() * 120 + 30, dif:0 },\r\n            turn: { min:PI/2, dif:(TWO_PI) },\r\n            mirror: num % 2 == 0,\r\n            children:[]\r\n        };\r\n        dad.push(neo);\r\n        total += dn * num;\r\n\r\n        if(Math.random() < 0.7) {\r\n            console.log(\"child\", num, dn, total);\r\n            dad = neo.children;\r\n            dn *= num;\r\n\r\n        } else {\r\n            console.log(\"sibling\", num, dn, total);\r\n        }\r\n    }\r\n\r\n    def.net[0].pos = [windowWidth/2, windowHeight/2];\r\n\r\n    console.log(total, def);\r\n    return def;\r\n}\r\n\r\nfunction draw() {\r\n  if(go) {\r\n      background(\"#FFFFFF\");\r\n      for(let g of graphs) {\r\n          moveNode(g.root);\r\n          //drawNode(g.root);\r\n          render.render(g.root);\r\n      }\r\n\r\n      t++;\r\n  }\r\n}\r\n\r\nfunction makeGroup(g, dad, graph) {\r\n    //console.log(\"makeGroup\", g);\r\n    for(let i=0; i<g.num; i++) {\r\n        let n = new Node();\r\n        n.ix = i;\r\n        n.nrm = g.num == 1 ? 0 : (1 / (g.num)) * i;\r\n        n.parent = dad;\r\n        n.parent.kids.push(n);\r\n        n.depth = dad.depth+1;\r\n\r\n        graph.count ++;\r\n        graph.depth = Math.max(graph.depth, n.depth);\r\n        //console.log(n);\r\n\r\n        if(g.type == \"chain\" && i > 0) {\r\n            n.anchor = n.parent.kids[i-1];\r\n        } else {\r\n            n.anchor = dad;\r\n        }\r\n\r\n        n.turn = isNaN(g.turn) ? parseCurve(g.turn, n) : g.turn;// n.parent.turn + g.turn * n.ix;\r\n        n.rot = 0;\r\n        n.step = isNaN(g.step) ? parseCurve(g.step, n) : g.step;\r\n\r\n        if(g.children) {\r\n            for(let j=0; j<g.children.length; j++) {\r\n                makeGroup(g.children[j], n, graph);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/***** GRAPH *****/\r\nclass Graph {\r\n  constructor(args = {}) {\r\n    this.ix = graphs.length;\r\n    this.count = 0;\r\n    this.depth = 0;\r\n\r\n    this.root = new Node();\r\n    for(let i=0; i<args.net.length; i++){\r\n        makeGroup(args.net[i], this.root, this);\r\n    }\r\n\r\n    console.log(\"graph\", this);\r\n  }\r\n}\r\n\r\n/***** NODE *****/\r\nclass Node {\r\n  constructor(args = {}) {\r\n      //properties\r\n      this.ix = args.ix || 0;\r\n      this.nrm = args.nrm || 0;\r\n      this.rnd = args.rnd || Math.random();\r\n      this.pos = args.pos || [windowWidth/2, windowHeight/2];\r\n      this.step = args.step || 30;\r\n      this.turn = args.turn || 0;\r\n      this.rot = args.rot || 0;\r\n      this.mirrot = args.mirror || false;\r\n      this.size = args.size || 20;\r\n      this.weight = args.weight || 1;\r\n      this.depth = args.depth || 0;\r\n\r\n      // Node references\r\n      this.parent = args.parent || null;\r\n      this.anchor = args.anchor || null;\r\n      this.kids = args.kids || [];\r\n\r\n  }\r\n}\r\n\r\n\r\nfunction ease(type, t, p) {\r\n    if(type == \"simple\") {\r\n        return p < 0 ? 1 - Math.pow(1-t, Math.abs(p)) : Math.pow(t, Math.abs(p));\r\n    } else if (type == \"IO\") {\r\n        //if(t < 0.5) return easeSimple(t*2, p) * 0.5;\r\n        //else return (1 - easeSimple(1-(t-0.5)*2, p)) * 0.5 + 0.5;\r\n        if(t < 0.5) return (p < 0 ? 1 - Math.pow(1-t*2, Math.abs(p)) : Math.pow(t*2, Math.abs(p))) * 0.5;\r\n        else return (1 - (p < 0 ? 1 - Math.pow(1-(1-(t-0.5)*2), Math.abs(p)) : Math.pow(1-(t-0.5)*2, Math.abs(p)))) * 0.5 + 0.5;\r\n    } else if (type == \"hill\") {\r\n        t = t < 0.5 ? t * 2 : 1 - (t-0.5)*2;\r\n        return p < 0 ? 1 - Math.pow(1-t, Math.abs(p)) : Math.pow(t, Math.abs(p));\r\n    } else if (type == \"sine\") {\r\n        return Math.sin(t*p*Math.PI*2) * 0.5 + 0.5;\r\n    } else if (type == \"noise\") {\r\n        return noise(t*16);\r\n    } else {\r\n        return t;\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction mousePressed() {\r\n  //pen.set(mouseX, mouseY);\r\n}\r\n\r\nfunction keyTyped() {\r\n  if (key === ' ') {\r\n    go = !go;\r\n    console.log(\"go\", go);\r\n  } else if(key === 'r') {\r\n    reset();\r\n  } else if(key === 's') {\r\n      let gt = getTime();\r\n    saveCanvas(\"collider-\"+ gt +\".jpg\");\r\n    saveJSON(defs, \"collider-\"+ gt +\".jpg\", false);\r\n  } else if(key === 'g') {\r\n    generate();\r\n  }  else if(key === 'e') {\r\n      if(editor.style(\"display\") == \"block\") editor.hide();\r\n      else editor.show();\r\n  }\r\n  // uncomment to prevent any default behavior\r\n  //return false;\r\n}\r\n\r\nfunction contrast(n, f) {\r\n  return constrain(f*(n-0.5) + 0.5, 0, 1);\r\n}\r\n\r\nfunction getTime() {\r\n  let now = new Date();\r\n  return now.getFullYear().toString().substring(2,4) +\r\n        (now.getMonth() + 1).toString().padStart(2, \"0\") +\r\n        (now.getDate()).toString().padStart(2, \"0\") + \"-\" +\r\n        (now.getHours()).toString().padStart(2, \"0\") +\r\n        (now.getMinutes()).toString().padStart(2, \"0\") +\r\n        (now.getSeconds()).toString().padStart(2, \"0\");\r\n}\r\n\r\nfunction windowResized() {\r\n  resizeCanvas(windowWidth, windowHeight);\r\n  canvas.parent('container');\r\n  background(\"#FFFFFF\");\r\n}\r\n","function parseCurve(c, n) {\r\n    c.terms = c.terms || \"ix\";\r\n\r\n    let out = {};\r\n    out.ease = c.ease || \"none\";\r\n    out.pow = c.pow || 2;\r\n    out.min = c.min || 0;\r\n    //out.max = c.max || 1;\r\n    out.dif = c.dif || 0;\r\n    out.dur = c.dur || 0;\r\n\r\n    out.base = 0;\r\n    out.time = 0;\r\n\r\n    let ts = c.terms.split('+')\r\n    for(let t of ts) {\r\n        let ps = t.split('*');\r\n        if(ps[0] == 't' || ps[0] == 'time') {\r\n            out.time = ps.length > 1 ? parseFloat(ps[1]) : 1;\r\n        } else {\r\n            let trm = 1;\r\n            for(let p of ps) {\r\n                if(p == \"ix\") trm *= n.nrm;\r\n                else if(p == \"rnd\") trm *= n.rnd;\r\n                else if(p == \"noise\") trm *= noise(n.parent.nrm, n.nrm);\r\n                else if(p == \"dix\") trm *= n.parent.nrm;\r\n                else if(p == \"drnd\") trm *= n.parent.rnd;\r\n                else trm *= parseFloat(p);\r\n            }\r\n            out.base += trm;\r\n        }\r\n    }\r\n    //console.log(out);\r\n\r\n    return out;\r\n}\r\n\r\nfunction moveNode(n) {\r\n    if(n.anchor !== null) {\r\n        let trn;\r\n        if(isNaN(n.turn)) {\r\n            let x = n.turn.base;\r\n            if(n.turn.dur > 0) x += (1 / n.turn.dur) * (t % (n.turn.dur+1)) * n.turn.time;\r\n            x %= 1;\r\n            trn = n.parent.rot + (n.turn.min + ease(n.turn.ease, x, n.turn.pow) * n.turn.dif);\r\n            //if(n.parent.ix == 1) console.log(n.ix, n.parent.rot, n.turn.min, n.turn.ease, n.turn.pow, n.turn.dif);\r\n        } else {\r\n            trn = n.parent.rot + n.turn * n.ix;\r\n        }\r\n        let _mirror = int(n.parent.anchor != null && n.parent.mirror && n.parent.anchor.ix%2 == 0) ^ int( n.mirror && n.parent.ix%2 == 0);\r\n\r\n        n.rot = _mirror? n.parent.rot - trn : n.parent.rot + trn;\r\n        //n.rot %= (Math.PI*2);\r\n\r\n        let stp;\r\n        if(isNaN(n.step)) {\r\n            let x = n.step.base;\r\n            if(n.step.dur > 0) x += (1 / n.step.dur) * (t % (n.step.dur+1)) * n.step.time;\r\n            x %= 1;\r\n            stp = n.step.min + ease(n.step.ease, x, n.step.pow) * n.step.dif;\r\n            //if(n.parent.ix == 1) console.log(n.ix, stp, n.step.dif);\r\n        } else {\r\n            stp = n.step;\r\n        }\r\n        //console.log(n.ix, (0.999 / n.step.dur) * (t % (n.step.dur+1)) * n.step.time);\r\n\r\n        n.pos = [\r\n            n.anchor.pos[0] + stp * cos(n.rot),\r\n            n.anchor.pos[1] + stp * sin(n.rot)\r\n        ]\r\n    }\r\n\r\n    for(let k of n.kids) {\r\n        moveNode(k);\r\n    }\r\n}\r\n","\r\nfunction drawNode(n) {\r\n    if(n.anchor != null) line(n.anchor.pos[0], n.anchor.pos[1], n.pos[0], n.pos[1]);\r\n    ellipse(n.pos[0], n.pos[1], 10, 10);\r\n\r\n    for(let k of n.kids) {\r\n        drawNode(k);\r\n    }\r\n}\r\n\r\nclass RenderCurves {\r\n    constructor(df = {}) {\r\n        let args = df.props.renderConfig || {};\r\n\r\n        this.type = args.type || \"star\";\r\n        this.levels = args.levels || [[0, 1, 1]];\r\n\r\n    }\r\n\r\n    render(n) {\r\n        for(let lv of this.levels) {\r\n            //stroke( lv[0] );\r\n            //strokeWeight( lv[1] || 1 );\r\n            //strokeWeight( (n.depth) * lv[1]);\r\n            //console.log(n.depth, lv[1]);\r\n            //fill(192);\r\n            this.renderNode(n, lv);\r\n        }\r\n    }\r\n\r\n    renderNode(n, level) {\r\n        stroke(level[0]);\r\n        strokeWeight( (n.depth+1) * level[1] );\r\n\r\n        if(this.type == \"bezier\") {\r\n            if(n.kids.length > 2) {\r\n                for(let k=1; k<n.kids.length-1; k++) {\r\n                    let ps = [\r\n                        n.kids[k-1].pos[0] + (n.kids[k].pos[0] - n.kids[k-1].pos[0]) / 2,\r\n                        n.kids[k-1].pos[1] + (n.kids[k].pos[1] - n.kids[k-1].pos[1]) / 2,\r\n                        n.kids[k].pos[0],\r\n                        n.kids[k].pos[1],\r\n                        n.kids[k].pos[0] + (n.kids[k+1].pos[0] - n.kids[k].pos[0]) / 2,\r\n                        n.kids[k].pos[1] + (n.kids[k+1].pos[1] - n.kids[k].pos[1]) / 2\r\n                    ];\r\n                    bezier(ps[0], ps[1], ps[2], ps[3], ps[2], ps[3], ps[4], ps[5]);\r\n                }\r\n            }\r\n        } else if(this.type == \"bezier-closed\") {\r\n            if(n.kids.length > 2) {\r\n                for(let k=0; k<n.kids.length; k++) {\r\n                    let prv = k==0 ? n.kids.length-1 : k-1;\r\n                    let nxt = k==n.kids.length-1 ? 0 : k+1;\r\n                    let ps = [\r\n                        n.kids[prv].pos[0] + (n.kids[k].pos[0] - n.kids[prv].pos[0]) / 2,\r\n                        n.kids[prv].pos[1] + (n.kids[k].pos[1] - n.kids[prv].pos[1]) / 2,\r\n                        n.kids[k].pos[0],\r\n                        n.kids[k].pos[1],\r\n                        n.kids[k].pos[0] + (n.kids[nxt].pos[0] - n.kids[k].pos[0]) / 2,\r\n                        n.kids[k].pos[1] + (n.kids[nxt].pos[1] - n.kids[k].pos[1]) / 2\r\n                    ];\r\n                    bezier(ps[0], ps[1], ps[2], ps[3], ps[2], ps[3], ps[4], ps[5]);\r\n                }\r\n            }\r\n        } else if(this.type == \"polygon\") {\r\n            if(n.kids.length > 1) {\r\n                for(let k=1; k<n.kids.length; k++) {\r\n                    line(n.kids[k-1].pos[0], n.kids[k-1].pos[1], n.kids[k].pos[0], n.kids[k].pos[1]);\r\n                }\r\n            }\r\n        } else if(this.type == \"tree\") {\r\n            for(let k=0; k<n.kids.length; k++) {\r\n                line(n.pos[0], n.pos[1], n.kids[k].pos[0], n.kids[k].pos[1]);\r\n            }\r\n        } else if(this.type == \"circles\") {\r\n            for(let k=0; k<n.kids.length; k++) {\r\n                ellipse( n.kids[k].pos[0], n.kids[k].pos[1], n.kids[k].size, n.kids[k].size);\r\n            }\r\n        }  else if(this.type == \"star\") {\r\n            if(n.kids.length > 1) {\r\n                for(let k=1; k<n.kids.length; k++) {\r\n                    bezier(n.kids[k-1].pos[0], n.kids[k-1].pos[1], n.pos[0], n.pos[1], n.pos[0], n.pos[1], n.kids[k].pos[0], n.kids[k].pos[1]);\r\n                }\r\n            }\r\n        } else if(this.type == \"umbrella\") {\r\n            if(n.kids.length > 1) {\r\n                for(let k=1; k<n.kids.length; k++) {\r\n                    let hlf = [ (n.kids[k-1].pos[0] - n.kids[k].pos[0]) / 2, (n.kids[k-1].pos[1] - n.kids[k].pos[1]) / 2 ];\r\n                    let anc = [ (n.kids[k].pos[0] + hlf[0]) - hlf[1], (n.kids[k].pos[1] + hlf[1]) + hlf[0] ];\r\n                    bezier(n.kids[k].pos[0], n.kids[k].pos[1], anc[0], anc[1], anc[0], anc[1], n.kids[k-1].pos[0], n.kids[k-1].pos[1]);\r\n                }\r\n            }\r\n        } else if(this.type == \"snake\") {\r\n            if(n.kids.length > 1) {\r\n                for(let k=1; k<n.kids.length; k++) {\r\n                    let hlf = [ (n.kids[k-1].pos[0] - n.kids[k].pos[0]) / 2, (n.kids[k-1].pos[1] - n.kids[k].pos[1]) / 2 ];\r\n                    let anc = [\r\n                        (n.kids[k].pos[0] + hlf[0]) - hlf[1], (n.kids[k].pos[1] + hlf[1]) + hlf[0],\r\n                        (n.kids[k].pos[0] + hlf[0]) + hlf[1], (n.kids[k].pos[1] + hlf[1]) - hlf[0]\r\n                    ];\r\n                    bezier(n.kids[k].pos[0], n.kids[k].pos[1], anc[0], anc[1], anc[2], anc[3], n.kids[k-1].pos[0], n.kids[k-1].pos[1]);\r\n                }\r\n            }\r\n        }  else if(this.type == \"petals\") {\r\n            if(n.kids.length > 1) {\r\n                for(let k=1; k<n.kids.length; k++) {\r\n                    let hlf = [ (n.kids[k-1].pos[0] - n.kids[k].pos[0]) / 2, (n.kids[k-1].pos[1] - n.kids[k].pos[1]) / 2 ];\r\n                    let pts = [\r\n                        (n.kids[k].pos[0] + hlf[0]) - hlf[1], (n.kids[k].pos[1] + hlf[1]) + hlf[0],\r\n                        (n.kids[k].pos[0] + hlf[0]) + hlf[1], (n.kids[k].pos[1] + hlf[1]) - hlf[0]\r\n                    ];\r\n                    bezier(pts[0], pts[1], n.kids[k-1].pos[0], n.kids[k-1].pos[1], n.kids[k-1].pos[0], n.kids[k-1].pos[1], pts[2], pts[3]);\r\n                    bezier(pts[0], pts[1], n.kids[k].pos[0], n.kids[k].pos[1], n.kids[k].pos[0], n.kids[k].pos[1], pts[2], pts[3]);\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        for(let k of n.kids) {\r\n            this.renderNode(k, level);\r\n        }\r\n    }\r\n}\r\n"]}